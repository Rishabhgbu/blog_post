{"ast":null,"code":"// Scroll animations utility\nexport const initScrollAnimations = () => {\n  const observerOptions = {\n    threshold: 0.1,\n    rootMargin: '0px 0px -50px 0px'\n  };\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        entry.target.classList.add('visible');\n        // Once visible, unobserve to avoid repeated work\n        observer.unobserve(entry.target);\n      }\n    });\n  }, observerOptions);\n\n  // Observe all elements with fade-in-on-scroll class\n  const animatedElements = document.querySelectorAll('.fade-in-on-scroll');\n  animatedElements.forEach(el => observer.observe(el));\n\n  // Also observe future elements dynamically added to the DOM\n  const mutationObserver = new MutationObserver(mutations => {\n    mutations.forEach(mutation => {\n      mutation.addedNodes.forEach(node => {\n        var _node$querySelectorAl;\n        if (!(node instanceof HTMLElement)) return;\n        // If the added node itself has the class\n        if (node.classList && node.classList.contains('fade-in-on-scroll')) {\n          observer.observe(node);\n        }\n        // Or if any of its descendants have the class\n        const descendants = (_node$querySelectorAl = node.querySelectorAll) === null || _node$querySelectorAl === void 0 ? void 0 : _node$querySelectorAl.call(node, '.fade-in-on-scroll');\n        if (descendants && descendants.length) {\n          descendants.forEach(el => observer.observe(el));\n        }\n      });\n    });\n  });\n  mutationObserver.observe(document.body, {\n    childList: true,\n    subtree: true\n  });\n  return {\n    disconnect: () => {\n      observer.disconnect();\n      mutationObserver.disconnect();\n    }\n  };\n};\n\n// Parallax effect for background elements\nexport const initParallaxEffect = () => {\n  const handleScroll = () => {\n    const scrolled = window.pageYOffset;\n    const parallaxElements = document.querySelectorAll('.parallax-element');\n    parallaxElements.forEach(element => {\n      const speed = element.dataset.speed || 0.5;\n      const yPos = -(scrolled * speed);\n      element.style.transform = `translateY(${yPos}px)`;\n    });\n  };\n  window.addEventListener('scroll', handleScroll);\n  return () => window.removeEventListener('scroll', handleScroll);\n};\n\n// Smooth scroll to top\nexport const scrollToTop = () => {\n  window.scrollTo({\n    top: 0,\n    behavior: 'smooth'\n  });\n};\n\n// Add ripple effect to buttons\nexport const addRippleEffect = event => {\n  const button = event.currentTarget;\n  const ripple = document.createElement('span');\n  const rect = button.getBoundingClientRect();\n  const size = Math.max(rect.width, rect.height);\n  const x = event.clientX - rect.left - size / 2;\n  const y = event.clientY - rect.top - size / 2;\n  ripple.style.width = ripple.style.height = size + 'px';\n  ripple.style.left = x + 'px';\n  ripple.style.top = y + 'px';\n  ripple.classList.add('ripple');\n  button.appendChild(ripple);\n  setTimeout(() => {\n    ripple.remove();\n  }, 600);\n};","map":{"version":3,"names":["initScrollAnimations","observerOptions","threshold","rootMargin","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","classList","add","unobserve","animatedElements","document","querySelectorAll","el","observe","mutationObserver","MutationObserver","mutations","mutation","addedNodes","node","_node$querySelectorAl","HTMLElement","contains","descendants","call","length","body","childList","subtree","disconnect","initParallaxEffect","handleScroll","scrolled","window","pageYOffset","parallaxElements","element","speed","dataset","yPos","style","transform","addEventListener","removeEventListener","scrollToTop","scrollTo","top","behavior","addRippleEffect","event","button","currentTarget","ripple","createElement","rect","getBoundingClientRect","size","Math","max","width","height","x","clientX","left","y","clientY","appendChild","setTimeout","remove"],"sources":["C:/Users/risha/OneDrive/Desktop/blog app/public/src/utils/scrollAnimations.js"],"sourcesContent":["// Scroll animations utility\nexport const initScrollAnimations = () => {\n  const observerOptions = {\n    threshold: 0.1,\n    rootMargin: '0px 0px -50px 0px'\n  };\n\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        entry.target.classList.add('visible');\n        // Once visible, unobserve to avoid repeated work\n        observer.unobserve(entry.target);\n      }\n    });\n  }, observerOptions);\n\n  // Observe all elements with fade-in-on-scroll class\n  const animatedElements = document.querySelectorAll('.fade-in-on-scroll');\n  animatedElements.forEach(el => observer.observe(el));\n\n  // Also observe future elements dynamically added to the DOM\n  const mutationObserver = new MutationObserver((mutations) => {\n    mutations.forEach(mutation => {\n      mutation.addedNodes.forEach(node => {\n        if (!(node instanceof HTMLElement)) return;\n        // If the added node itself has the class\n        if (node.classList && node.classList.contains('fade-in-on-scroll')) {\n          observer.observe(node);\n        }\n        // Or if any of its descendants have the class\n        const descendants = node.querySelectorAll?.('.fade-in-on-scroll');\n        if (descendants && descendants.length) {\n          descendants.forEach(el => observer.observe(el));\n        }\n      });\n    });\n  });\n  mutationObserver.observe(document.body, { childList: true, subtree: true });\n\n  return {\n    disconnect: () => {\n      observer.disconnect();\n      mutationObserver.disconnect();\n    }\n  };\n};\n\n// Parallax effect for background elements\nexport const initParallaxEffect = () => {\n  const handleScroll = () => {\n    const scrolled = window.pageYOffset;\n    const parallaxElements = document.querySelectorAll('.parallax-element');\n    \n    parallaxElements.forEach(element => {\n      const speed = element.dataset.speed || 0.5;\n      const yPos = -(scrolled * speed);\n      element.style.transform = `translateY(${yPos}px)`;\n    });\n  };\n\n  window.addEventListener('scroll', handleScroll);\n  return () => window.removeEventListener('scroll', handleScroll);\n};\n\n// Smooth scroll to top\nexport const scrollToTop = () => {\n  window.scrollTo({\n    top: 0,\n    behavior: 'smooth'\n  });\n};\n\n// Add ripple effect to buttons\nexport const addRippleEffect = (event) => {\n  const button = event.currentTarget;\n  const ripple = document.createElement('span');\n  const rect = button.getBoundingClientRect();\n  const size = Math.max(rect.width, rect.height);\n  const x = event.clientX - rect.left - size / 2;\n  const y = event.clientY - rect.top - size / 2;\n  \n  ripple.style.width = ripple.style.height = size + 'px';\n  ripple.style.left = x + 'px';\n  ripple.style.top = y + 'px';\n  ripple.classList.add('ripple');\n  \n  button.appendChild(ripple);\n  \n  setTimeout(() => {\n    ripple.remove();\n  }, 600);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}